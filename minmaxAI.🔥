from board import Board
from array import Array

"""
Author: Erin Green

Description: This is the struct for the basic AI, which has a very simplicstic
desicion-making algorithm, which is essentially random decisions.

To use this AI, simply call the choice function and pass in the board. The AI will return
an integer representing the column in which it wants to play.
"""
struct min_max_ai:
   var player: Int
   var opponent: Int
   var maxDepth : Int

   #so we know which pieces are ours
   fn __init__(inout self, player: Int, opponent: Int) -> None:
      self.player = player
      self.opponent = opponent
      self.maxDepth = 5

   #returns the column in which it wants to place a piece
   fn makeChoice(self, b: Board) -> Int:
     #set up an array to keep track of "game" score
     var scores = Array[Int](b.__cols, 0)
     var bestScore = -1
     var bestChoice = -1
     var valid = False
     var i = 0

     #find first valid move
     while valid == False and i < b.__cols:
      var temp = b
      valid = temp.playPiece(self.player,i)
      temp.__del__()
      if valid:
         bestChoice = i
         bestScore = scores.__getitem__(i)
      i += 1
   
     self.min_max_alg(0, b, self.player, -1, scores)

     #choose best choice and move on
     for i in range(0, b.__cols):
        var temp = b
        valid = temp.playPiece(self.player,i)
        var score = scores.__getitem__(i)
        print("I: ", i, "Score: ", score)
        if score > bestScore and valid == True:
            bestScore = score
            bestChoice = i
   
     return bestChoice

   #choice is the very first choice made, 
   fn min_max_alg(self, depth: Int, b: Board, player: Int, choice: Int, inout scores: Array[Int]) -> None:
      var bestChoice = 0
      var temp = b
      let win = temp.checkForWinner()
      let nextPlayer = self.player if player == self.opponent else self.opponent
      
      temp.__del__()
      #if board has winner, set appropriate score
      if win == True:
         let currentScore = scores.__getitem__(choice)
         if player == self.player:
            scores.__setitem__(choice, currentScore-10)
            return
         else:
            if depth == 1:
               scores.__setitem__(choice, 100000)
            else:
               scores.__setitem__(choice, currentScore+10)
            return
      elif depth == self.maxDepth:
         return

      #otherwise loop through each col, attempting to make a move as a player
      for i in range(0, b.__cols):
         var copy = b
         var validMove = copy.playPiece(player,i)
         if validMove == True:
            if choice == -1:
               self.min_max_alg(depth+1, copy, nextPlayer, i, scores)
            else:
               self.min_max_alg(depth+1, copy, nextPlayer, choice, scores)
         copy.__del__()

   
