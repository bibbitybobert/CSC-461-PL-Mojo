from board import Board
from array import Array

struct max_ai:
    var __id: Int
    var __max_depth: Int

    fn __init__(inout self, forward_sight: Int, id: Int):
        self.__max_depth = forward_sight

    fn makeChoice(self, b: Board) -> Int:
        return self.max_alg(b, 0, True).get[1, Int]()

    fn max_alg(self, b:Board, depth:Int, maxPlayer:Bool) -> (Int, Int):
        # get all valid locations to play
        var all_valid_cols: Array[Bool] = self.get_valid_cols(b)
        # check if win possible
        var win_col: Int = self.win_possible(b)

        if depth == self.__max_depth:
        #   return score of current spot
            return 0, self.current_score()
        elif win_col != -1:
            return win_col, 100
        else:
            return -1, 0

        var value = 0
        for i in range(all_valid_cols.size):
            #   copy board and play peice at col
            if all_valid_cols[i] == True:
                var b_copy: Board = b
                if maxPlayer:
                    b_copy.playPiece(self.__id, i)
                else:
                    b_copy.playPiece(enemyId, i)
                var new_score = self.max_alg(b_copy, depth + 1, maxPlayer ^ True).get[1, Int]()
                if new_score > value:
                    value = new_score
                    col_choice = col
        return col_choice, value
        #   new_score = self.max_alg(bcopy_board, depth + 1, maxPlayer ^ True).get[1, Int]()
        #   if new_score > value:
        #       value = new_score
        #       col_choice = col
        #return col_choice, value

    fn get_valid_cols(self, b: Board) -> Array[Bool]:
        var valid_col_arry: Array[Bool] = Array[Bool](b.__cols, False)
        for i in range(b.__cols):
            if b.__piecesInColumns[i] != b.__rows:
                valid_col_arry[i] = True

    fn win_possible(self, b:Board) -> Int:
        for i in range(b.__cols):
            var copy:Board = b # need keiran to implement board copy functionality
            copy.playPiece(self.__id, i)
            if copy.checkForWinner():
                return i
        return -1

    fn current_score(self) -> Int:
